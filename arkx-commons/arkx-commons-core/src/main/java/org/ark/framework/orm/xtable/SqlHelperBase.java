package org.ark.framework.orm.xtable;

import java.util.List;

import io.arkx.framework.commons.collection.DataRow;
import io.arkx.framework.commons.collection.DataTable;
import io.arkx.framework.data.jdbc.SessionFactory;

/// SqlHelperBase,用于数据库存取操作的一些基类封装,静态类,不提供实例化方法。
public class SqlHelperBase {

	// #region ExecuteDatatable
	// / <summary>
	// / 使用查询语句取得一个DataTable
	// / </summary>
	// / <param name="m_connectionString">数据库连接字符串</param>
	// / <param name="commandText">查询语名,形如“select * from a where b=1”</param>
	// / <returns>DataTable</returns>
	public static DataTable ExecuteDatatable(String m_connectionString, String commandText) {
		return SessionFactory.openSession().readOnly().createQuery(commandText).executeDataTable();
	}

	// #endregion

	// #region ExecuteReader

	// #region ExecuteDatarow
	// / <summary>
	// / Execute a SqlCommand (that returns a resultset)
	// /
	// / e.g.:
	// / DataRow dr = ExecuteDatarow("select * from a");
	// / </summary>
	// / <param name="m_connectionString">the SqlConnection to be
	// connect</param>
	// / <param name="commandText">the T-SQL command</param>
	// / <returns>returns a datarow containing the resultset generated by the
	// command</returns>
	public static DataRow ExecuteDatarow(String m_connectionString, String commandText) {
		DataTable dataTable = ExecuteDatatable(m_connectionString, commandText);
		if (dataTable != null && dataTable.getRowCount() > 0) {
			return dataTable.get(0);
		}
		return null;
		// DataSet ds = ExecuteDataset(m_connectionString ,commandText);
		// //return the datarow
		// if (ds.Tables[0].Rows.Count>0)
		// return ds.Tables[0].Rows[0];
		// else
		// return (DataRow)null;
	}

	// #endregion

	// #region ExecuteScalar
	// / <summary>
	// / Execute a SqlCommand (that returns a 1x1 resultset)
	// /
	// / e.g.:
	// / int orderCount = (int)ExecuteScalar("select max(b) from a");
	// / </summary>
	// / <param name="m_connectionString">the SqlConnection to be
	// connect</param>
	// / <param name="commandText">SqlCommand Text</param>
	// / <returns> returns an object containing the value in the 1x1 resultset
	// generated by the command</returns>
	public static Object ExecuteScalar(String m_connectionString, String commandText) {
		return SessionFactory.openSession().readOnly().createQuery(commandText).executeOneValue();
	}

	// / <summary>
	// / 对ExecuteScalar方法的扩展，将结果转化为String
	// / 本函数对查询结果为空时返回""，以防调用者未加检测而报错（这也是编写本函数的目的）
	// / </summary>
	// / <param name="m_connectionString">数据库连接字符串</param>
	// / <param name="commandText">sql语句，形如“select usrname from usr where
	// id=3”</param>
	// / <returns>一个String值，若查询未得到一行记录，则返回""</returns>
	public static String ExecuteScalarString(String m_connectionString, String commandText) {
		Object retval = ExecuteScalar(m_connectionString, commandText);
		if (retval == null)
			return "";
		return retval.toString();
	}

	// #endregion

	// #region GetPK
	// / <summary>
	// / Execute a SqlCommand (that returns an int number for the table's max ID
	// for insert)
	// /
	// / e.g.:
	// / int newUserIdForInsert = SqlHelperBase.GetPK("users","userId")
	// /
	// / </summary>
	// / <param name="m_connectionString">the SqlConnection to be
	// connect</param>
	// / <param name="tableName">table's name</param>
	// / <param name="columnName">columnName's name,the column must be the PK
	// and not an increment column</param>
	// / <returns> returns an int value</returns>
	public static int GetPK(String m_connectionString, String tableName, String columnName) {
		return Integer.parseInt(
				ExecuteScalar(m_connectionString, "select isnull(max(" + columnName + "),0)+1 as col from " + tableName)
					.toString());
	}

	// / <summary>
	// / Execute a SqlCommand (that returns an int number for the table's max ID
	// for insert)
	// /
	// / e.g.:
	// / int newUserIdForInsert = SqlHelperBase.GetPK("users","userId",20,30)
	// / 取得在20-30之间的一个可插入值
	// / </summary>
	// / <param name="m_connectionString">the SqlConnection to be
	// connect</param>
	// / <param name="tableName">table's name</param>
	// / <param name="columnName">columnName's name,the column must be the PK
	// and not an increment column</param>
	// / <param name="minValue"></param>
	// / <param name="maxValue"></param>
	// / <returns> returns an int value</returns>
	public static int GetPK(String m_connectionString, String tableName, String columnName, int minValue,
			int maxValue) {
		return Integer
			.parseInt(ExecuteScalar(m_connectionString,
					"select isnull(max(" + columnName + ")," + (minValue - 1) + ")+1 as col from " + tableName
							+ " where " + columnName + ">=" + minValue + " and " + columnName + "<" + maxValue)
				.toString());
	}

	// #endregion

	// #region GetInsertedPK
	// / <summary>
	// / 取得指定表最后一次插入的ID，若无法取得，则返回int.MinValue
	// / 注意：未测试本函数对“某表同时有一自增长列和一主键列”的情形
	// / 注意：若某表的主键字段不是数字型（例如“用客户名称作为主键”的情形），则调用此函数可能引起运行时错误
	// / </summary>
	// / <param name="m_connectionString">数据库连接字符串</param>
	// / <param name="tableName">被指定的表</param>
	// / <returns>一个int型的值</returns>
	public static int GetInsertedPK(String m_connectionString, String tableName) {
		Object obj = ExecuteScalar(m_connectionString, "SELECT IDENT_CURRENT('" + tableName + "')");
		if (obj == null)
			return Integer.MIN_VALUE;
		return Integer.parseInt(obj.toString());
	}

	// #endregion

	// #region GetIndexId(String tableName,String columnName,String m_where)

	// / <summary>
	// / 取得指定表的indexId,用于插入
	// / 返回一个可插入的String型值
	// / 因为此函数主要用于操作者在操作界面（例如添加新用户界面）上对“排序号”字段的默认值提供
	// / 所以返回String型
	// / </summary>
	// / <param name="m_connectionString">数据库连接字符串</param>
	// / <param name="tableName">表名，例如“usr”</param>
	// / <param name="columnName">列名，例如“indexId”</param>
	// / <param
	// name="m_where">不带“where”关键字的条件语名，例如“deptId=3”表示“在单位ID为3的所有人员中的排序”</param>
	// / <returns>返回一个可插入的String型值(在已有的最大值上加100，若无对比，则返回100)</returns>
	public static String GetIndexId(String m_connectionString, String tableName, String columnName, String m_where) {
		return GetIndexId(m_connectionString, tableName, columnName, m_where, 100);
	}

	// / <summary>
	// / 取得指定表的indexId,用于插入
	// / 返回一个可插入的String型值
	// / 因为此函数主要用于操作者在操作界面（例如添加新用户界面）上对“排序号”字段的默认值提供
	// / 所以返回String型
	// / </summary>
	// / <param name="m_connectionString">数据库连接字符串</param>
	// / <param name="tableName">表名，例如“usr”</param>
	// / <param name="columnName">列名，例如“indexId”</param>
	// / <param
	// name="m_where">不带“where”关键字的条件语名，例如“deptId=3”表示“在单位ID为3的所有人员中的排序”</param>
	// / <param name="amplitude">在已有的最大值上加该数作为返回值</param>
	// /
	// <returns>返回一个可插入的String型值(在已有的最大值上加amplitude，若无对比，则返回amplitude)</returns>
	public static String GetIndexId(String m_connectionString, String tableName, String columnName, String m_where,
			int amplitude) {
		return ExecuteScalarString(m_connectionString, "select isnull(max(cast(" + columnName + " as bigint)),0)+"
				+ amplitude + " as col from " + tableName + " where " + m_where);
	}

	// #endregion

	// #region DataRowExists

	// / <summary>
	// / 判断是否在 tableName 表中已存在符合 m_where 条件的记录
	// / </summary>
	// / <param name="m_connectionString">数据库连接字符串</param>
	// / <param name="tableName">表名</param>
	// / <param name="m_where">where条件，不可包含“where”关键字</param>
	// / <returns>存在则返回true,否则返回false</returns>
	public static boolean DataRowExists(String m_connectionString, String tableName, String m_where) {
		return DataRowCount(m_connectionString, tableName, m_where) > 0;
	}

	// / <summary>
	// / 得到在 tableName 表中符合 m_where 条件的记录行数
	// / </summary>
	// / <param name="m_connectionString">数据库连接字符串</param>
	// / <param name="tableName">表名</param>
	// / <param name="m_where">where条件，不可包含“where”关键字</param>
	// / <returns>返回在 tableName 表中符合 m_where 条件的记录行数</returns>
	public static int DataRowCount(String m_connectionString, String tableName, String m_where) {
		return Integer.parseInt(ExecuteScalarString(m_connectionString, "select count(" + tableName + "."
				+ TableStructList.Get(tableName).getPrimary().getName() + ") from " + tableName + " where " + m_where));
	}

	// #endregion DataRowExists

	// #region Get GUID()
	// / <summary>
	// / 利用数据库取一个GUID，注意每次获得的此值均是不同的
	// / </summary>
	public static String GUID(String m_connectionString) {
		String s = ExecuteScalarString(m_connectionString, "SELECT NEWID()").toUpperCase();
		if (s.indexOf("{") != 0) {
			return "{" + s + "}";
		}
		else {
			return s;
		}
	}

	// #endregion Get GUID()

	// #region GetResultString
	// / <summary>
	// / 取得一单列多行结果，将结果用“,”号分隔返回一个字符串
	// / 例如：“select distinct tablename from tailorformcol”
	// / 返回：“zfw,sbw,affair,commfun,……”
	// / </summary>
	// / <param name="m_connectionString"></param>
	// / <param name="commandText"></param>
	// / <returns></returns>
	public static String GetResultString(String m_connectionString, String commandText) {
		DataTable dt = ExecuteDatatable(m_connectionString, commandText);
		String s = "";
		for (int i = 0; i < dt.getRowCount(); i++) {
			if (i > 0) {
				s += ",";
			}
			s += dt.getString(i, 0);
		}
		return s;
	}

	// #endregion GetResultString

	// #region PatchDataTable 拼凑多个DataTable为一个
	// / <summary>
	// / 拼凑多个DataTable为一个
	// / </summary>
	// / <param name="dataTables"></param>
	// / <param name="sortExpression">排序字符串</param>
	// / <returns></returns>
	public static DataTable PatchDataTable(List<DataTable> dataTables, String sortExpression) {
		DataTable dt = new DataTable();
		if (dataTables.size() == 0) {
			return dt;
		}
		dt = (DataTable) (dataTables.get(0)).clone();
		for (int i = 0; i < dataTables.size(); i++) {
			// foreach (DataRow dr in m_dt.Rows)
			// {
			// dt.ImportRow(dr);
			// }
		}

		if (sortExpression == null || sortExpression.trim().length() == 0 || dt.getRowCount() <= 1) {
			return dt;
		}
		DataTable dtNew = (DataTable) dt.clone();
		DataRow[] drs = dt.Select("", sortExpression);
		for (int i = 0; i < drs.length; i++) {
			// dtNew.ImportRow(drs[i]);
		}
		return dtNew;
	}

	// / <summary>
	// / 拼凑多个DataTable为一个
	// / </summary>
	// / <param name="dataTables"></param>
	// / <returns></returns>
	public static DataTable PatchDataTable(List dataTables) {
		return PatchDataTable(dataTables, null);
	}
	// #endregion PatchDataTable 拼凑多个DataTable为一个

}
